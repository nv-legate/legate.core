<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legate: Data abstractions and allocators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legate<span id="projectnumber">&#160;22.12.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Data abstractions and allocators</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Store.html">legate::Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional data container storing task data.  <a href="classlegate_1_1Store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1Scalar.html">legate::Scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-erased container for scalars and tuples of scalars.  <a href="classlegate_1_1Scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlegate_1_1Span.html">legate::Span&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple span implementation used in Legate. Should eventually be replaced with std::span once we bump up the C++ standard version to C++20.  <a href="structlegate_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlegate_1_1ScopedAllocator.html">legate::ScopedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple allocator backed by <code>Buffer</code> objects.  <a href="classlegate_1_1ScopedAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gace5deff9e947b09c42a513cc83e2b0cf"><td class="memTemplParams" colspan="2">template&lt;typename VAL , int32_t DIM = 1&gt; </td></tr>
<tr class="memitem:gace5deff9e947b09c42a513cc83e2b0cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">legate::Buffer</a> = Legion::DeferredBuffer&lt; VAL, DIM &gt;</td></tr>
<tr class="memdesc:gace5deff9e947b09c42a513cc83e2b0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed buffer class for intra-task temporary allocations.  <a href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">More...</a><br /></td></tr>
<tr class="separator:gace5deff9e947b09c42a513cc83e2b0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac9cb47870d6cc84022b19e7bfd043600"><td class="memTemplParams" colspan="2">template&lt;typename VAL , int32_t DIM&gt; </td></tr>
<tr class="memitem:gac9cb47870d6cc84022b19e7bfd043600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">Buffer</a>&lt; VAL, DIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gac9cb47870d6cc84022b19e7bfd043600">legate::create_buffer</a> (const <a class="el" href="group__geometry.html#gad3f1c2668191a7a97740a5116d647b9d">Point</a>&lt; DIM &gt; &amp;extents, Memory::Kind kind=Memory::Kind::NO_MEMKIND, size_t alignment=16)</td></tr>
<tr class="memdesc:gac9cb47870d6cc84022b19e7bfd043600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>Buffer</code> of specific extents.  <a href="group__data.html#gac9cb47870d6cc84022b19e7bfd043600">More...</a><br /></td></tr>
<tr class="separator:gac9cb47870d6cc84022b19e7bfd043600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5bddc6d55aa9bb63f4120135237670"><td class="memTemplParams" colspan="2">template&lt;typename VAL &gt; </td></tr>
<tr class="memitem:ga0b5bddc6d55aa9bb63f4120135237670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">Buffer</a>&lt; VAL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga0b5bddc6d55aa9bb63f4120135237670">legate::create_buffer</a> (size_t size, Memory::Kind kind=Memory::Kind::NO_MEMKIND, size_t alignment=16)</td></tr>
<tr class="memdesc:ga0b5bddc6d55aa9bb63f4120135237670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>Buffer</code> of a specific size. Always returns a 1D buffer.  <a href="group__data.html#ga0b5bddc6d55aa9bb63f4120135237670">More...</a><br /></td></tr>
<tr class="separator:ga0b5bddc6d55aa9bb63f4120135237670"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gace5deff9e947b09c42a513cc83e2b0cf" name="gace5deff9e947b09c42a513cc83e2b0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace5deff9e947b09c42a513cc83e2b0cf">&#9670;&#160;</a></span>Buffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VAL , int32_t DIM = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">legate::Buffer</a> = typedef Legion::DeferredBuffer&lt;VAL, DIM&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typed buffer class for intra-task temporary allocations. </p>
<p >Values in a buffer can be accessed by index expressions with <a class="el" href="group__geometry.html#gad3f1c2668191a7a97740a5116d647b9d" title="Type for multi-dimensional points.">legate::Point</a> objects, or via a raw pointer to the underlying allocation, which can be queried with the <code>ptr</code> method.</p>
<p ><code><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf" title="A typed buffer class for intra-task temporary allocations.">legate::Buffer</a></code> is an alias to <a href="https://github.com/StanfordLegion/legion/blob/9ed6f4d6b579c4f17e0298462e89548a4f0ed6e5/runtime/legion.h#L3509-L3609"><code>Legion::DeferredBuffer</code></a>.</p>
<p >Note on using temporary buffers in CUDA tasks:</p>
<p >We use Legion <code>DeferredBuffer</code>, whose lifetime is not connected with the CUDA stream(s) used to launch kernels. The buffer is allocated immediately at the point when <code>create_buffer</code> is called, whereas the kernel that uses it is placed on a stream, and may run at a later point. Normally a <code>DeferredBuffer</code> is deallocated automatically by Legion once all the kernels launched in the task are complete. However, a <code>DeferredBuffer</code> can also be deallocated immediately using <code>destroy()</code>, which is useful for operations that want to deallocate intermediate memory as soon as possible. This deallocation is not synchronized with the task stream, i.e. it may happen before a kernel which uses the buffer has actually completed. This is safe as long as we use the same stream on all GPU tasks running on the same device (which is guaranteed by the current implementation of <code>get_cached_stream</code>), because then all the actual uses of the buffer are done in order on the one stream. It is important that all library CUDA code uses <code>get_cached_stream()</code>, and all CUDA operations (including library calls) are enqueued on that stream exclusively. This analysis additionally assumes that no code outside of Legate is concurrently allocating from the eager pool, and that it's OK for kernels to access a buffer even after it's technically been deallocated. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac9cb47870d6cc84022b19e7bfd043600" name="gac9cb47870d6cc84022b19e7bfd043600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9cb47870d6cc84022b19e7bfd043600">&#9670;&#160;</a></span>create_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VAL , int32_t DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">Buffer</a>&lt; VAL, DIM &gt; legate::create_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__geometry.html#gad3f1c2668191a7a97740a5116d647b9d">Point</a>&lt; DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Memory::Kind&#160;</td>
          <td class="paramname"><em>kind</em> = <code>Memory::Kind::NO_MEMKIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>Buffer</code> of specific extents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extents</td><td>Extents of the buffer </td></tr>
    <tr><td class="paramname">kind</td><td>Kind of the target memory (optional). If not given, the runtime will pick automatically based on the executing processor </td></tr>
    <tr><td class="paramname">alignment</td><td>Alignment for the memory allocation (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>Buffer</code> object </dd></dl>

</div>
</div>
<a id="ga0b5bddc6d55aa9bb63f4120135237670" name="ga0b5bddc6d55aa9bb63f4120135237670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b5bddc6d55aa9bb63f4120135237670">&#9670;&#160;</a></span>create_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#gace5deff9e947b09c42a513cc83e2b0cf">Buffer</a>&lt; VAL &gt; legate::create_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Memory::Kind&#160;</td>
          <td class="paramname"><em>kind</em> = <code>Memory::Kind::NO_MEMKIND</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>Buffer</code> of a specific size. Always returns a 1D buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the buffdr </td></tr>
    <tr><td class="paramname">kind</td><td>Kind of the target memory (optional). If not given, the runtime will pick automatically based on the executing processor </td></tr>
    <tr><td class="paramname">alignment</td><td>Alignment for the memory allocation (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 1D <code>Buffer</code> object </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
